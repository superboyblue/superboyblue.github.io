<!DOCTYPE html>
<head>
  <title>arrays and hashes</title>
  <meta charset="UTF-8">
  <link type="text/css" rel="stylesheet" href="\stylesheets\default.css">
  <link type="text/css" rel="stylesheet" href="\stylesheets\blog.css">
</head>
<body>
<main>
  <h1>Blog entry 3</h1>
  <h2>Array, array. Let's hash this out...</h2>
  <h4>Today's Date</h4>

  <section>
    <p>

<h2>Arrays and Hashes</h2>
<p>
Arrays and hashes are the great data storage warehouses of ruby. Arrays take any object you give them and keeps them in the order that they are received. They take objects and hold them forever (as long as you want them) in exactly the same position until you change it. So you might wonder how you're going to find an object in an array if they're just stuffed in there exactly the way they went in? Well, it turns out they're numerically ordered, or indexed in the order they were received (which starts at zero because that's how they roll). But what if you already put in an array and want to add some stuff to it? Turns out you can!
<p>
With special methods, you can add or remove objects from either end of the array. To add objects, you can use:
<br>
<br>
unshift - adds an object to the beginning
<br>
Say you have an array and you want to add something to the beginning because anything good always starts with puppies.
<br>
a = ["dogs","kittens","cats"]<br>
a.unshift ("puppies")<br>
=> ["puppies", "dogs", "kittens", "cats"]<br>
<br>
push - adds an object(s) to the end<br>
<br>
Oh no! What if, in some alternate dimension, you wrote the same array but forgot something towards the end?
<br>
a = ["puppies,"dogs","kittens"]<br>
a.push ("cats")<br>
=> ["puppies", "dogs", "kittens", "cats"]<br>
<br>
That was a close one. Push allows you to take more than one argument, so if you forgot 2 things at the end, don't sweat it. Ruby is here for you.
<br>
a = ["puppies","dogs"]<br>
a.push ("kittens","cats")<br>
=> ["puppies", "dogs", "kittens", "cats"]<br>
<br>
<< - adds an object (singular) to the end<br>
<br>
<p><br>
So you're wondering why we need the '<<' if we have push? I'm guessing it's for this situation: You're working at the animal shelter and you don't have much time before the great adoption event of the year! You need to make sure all the animals are in but your laptop is running low on battery and one of our fluffy little friends just ate your charger. What do you do? '<<' to the rescue! Save on keystrokes, save the day!
</p>
<br>
a = ["puppies","dogs","kittens"]<br>
a << "cats"<br>
=> ["puppies", "dogs", "kittens", "cats"]<br>
<br>
Insert - allows you to insert an object anywhere in the array, beginning middle or end
A well meaning couple brought an animal to the shelter which they thought could have been one of the four things that you take in, but turns out they maybe aren't the best at identifying animals? We've all been there! But have no fear, insert is here!
<br>
a = ["puppies","dogs","kittens, cats"<br>]
a.insert(2,"pandas")<br>
=> ["puppies", "dogs", "pandas", "kittens, cats"]<br>
<br>
The first argument that insert takes is the index position your new object is taking. The second argument, is the object itself. And that's how the local shelter was investigated by the government. 
<br>
<br>
In order to remove objects from your arrays, you can always use:<br>
<br>
Shift - removes an object from the beginning of an array
<br>
So you want to remove something from the beginning of an array? Maybe the first object is no longer available for whatever reason (maybe they all got adopted), and you want it out permanently? Hopefully they all grew up to be the second thing?
<br>
a = ["puppies","dogs","kittens","cats"]<br>
a.shift<br>
=> "puppies"<br>
<br>
Ruby returns the object that is removed, at least from the array. But the removal of puppies from anything will be seared into your memory forever!
<br>
pop - removes an object from the end of an array
<br>
The last item on the list need to go? They've all escaped and joined forces to take over the world and in the peace treaty, their demands were that from now on, cats would never be listed at any shelter ever again. But for whatever reason, they're okay with kittens being at the shelter because it builds character.
<br>
a = ["puppies","dogs","kittens","cats"]<br>
a.pop<br>
=> "cats"<br>
<br>
Ruby once again returns the object that is removed, as proof that you've done the bidding of the new feline overlords. 
<br>
Now, if you wanted to combine your arrays, there's something called concatenating. 
Say it's sometime in the past and felines and canines were in segragated shelters because it was common knowledge that they'd never get along. But today is the day that they can be united under one roof, to frolic and play amongst their other fuzzy friends!
<br>
So now you have two arrays that you want to combine:
<br>
["puppies","dogs"].concat(["kittens","cats"])<br>
=> ["puppies", "dogs", "kittens", "cats"]<br>
<br>
And they all lived happily ever after. <br>
<br>
What's that? You're wondering why you can't just push the kittens and cats into the puppies and dogs array?<br>
<br>
Well, as it turns out, one does not simply push kittens and cats. Because if you do, they aren't under one big roof (array) together frolicking. 
<br>
["puppies","dogs"].push(["kittens","cats"])<br>
=> ["puppies", "dogs", ["kittens", "cats"]]<br>
<br>
The kittens and cats are inside their array, inside the puppies and dogs array. And anyone who knows anything about cats knows they won't stand for that. <br>
<br>
Now on to hashes!<br>
So hashes store your info the way valets store your car in the garage. There's a spot for every car and each key/value (because cars are valuable to us) is unique. If you decide you want to switch values (cars), the old value is overwritten but the key(spot) remains the same. So you park in G2? and it's at the top floor and in the corner with the leaky pipe and you think they put you there because you have a crappy car? Well, you'll show them, won't you. You'll save up some money and buy a less crappy car, then they'll have to give you a better spot!  
<br>
garage = Hash.new<br>
<br>
garage ["crap_spot"] = "crap car"<br>
<br>
garage ["crap_spot"] = "less crap car"<br>
<br>
puts garage ["crap_spot"]<br>
less crap car<br>
=>nil<br>
<br>
That means that your car is still in the crap spot and the garage doesn't care. sad face.
<br>
But instead of replacing a car, maybe you'll just add a new one. You can do that by:
<br>
garage ["new spot"] = "second car" <br>
<br>
or
<br>
garage. [] = ("new spot" , "second car")<br>
<br>
You can also use tell them to store it for you using .store:<br>
<br>
garage.store("new spot" , "second car")<br>
<br>
Now in order to get your car, your beater first car because you're going to help a friend move, you do this:<br>
<br>
beater_car = garage("less crap car")<br>
<br>
You can also use fetch:<br>
<br>
beater_car = garage.fetch("less crap car")<br>
fetch gives you an exception whereas [] will tell you nil or something you specified. Mostly because fetch is rude.<br>
<br>
Say you need both vehicles because your friend is too irresponsible to have rented a truck and now is relying on you to do everything? Lucky for them (yes, I'm talking about you, Tommy), you have 2 vehicles that you're kind enough to ruin. 
<br>
both_cars = garage.values_at("less crap car","second car")<br>
<br>
And now you've gotten both your cars out of the garage. Unfortunately, only one will return. That has nothing to do with hashes and everything to do with Tommy.
<br>
For hashes, you can specify a default value if you ask for a value to a nonexistent key. Say you specify that you want them to bring you your Honda Civic whenever you ask for anything nonexistent, regardless of what you say. 
<br>
"Bring me my porsche."<br>
Brings Honda Civic.<br>
"Bring me my unicorn."<br>
Brings Honda Civic. <br>
<br>
garage = Hash.new("civic")
<br>
garage["porsche"]
<br>
=> "civic"
<br>
I don't really know if anyone at the garage will believe you after the first time that happens, but I guess it's a good way to look like someone trying to be something they aren't and being very bad at it. <br>
<br>
Hashes can also be combined. You can combine them together and make a third hash which destroys all the previous hashes that got it there by using update.
<br>
h1.update(h2)<br>
<br>
To do it without destroying the previous hashes, you can use merge.
<br>
h3 = h1.merge(h2)
<br>
<br>
<br>
So arrays and hashes are both great ways to store things, but while arrays can index only by number, hashes can index by anything you want. They're both combinable, easy to manipulate, and fun to use. Hashes allow for more flexible ways of getting your info, while arrays are more rigid and immutable. 
<p>
    
       
    

      <!-- copy and paste as many sections as you want to add paragraphs -->
  </section>
</main>
</body>
</html>